<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-面试指南/面试">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">集合中的泛型问题 | Mr zhang Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ZhRose.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ZhRose.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ZhRose.github.io/docs/面试指南/面试"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="集合中的泛型问题 | Mr zhang Blog"><meta data-rh="true" name="description" content="在Java中，List 表示一个元素为Animal或Animal的子类的列表。而 new ArrayList() 表示创建了一个ArrayList对象，并将其当做List类型的对象使用。"><meta data-rh="true" property="og:description" content="在Java中，List 表示一个元素为Animal或Animal的子类的列表。而 new ArrayList() 表示创建了一个ArrayList对象，并将其当做List类型的对象使用。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ZhRose.github.io/docs/面试指南/面试"><link data-rh="true" rel="alternate" href="https://ZhRose.github.io/docs/面试指南/面试" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://ZhRose.github.io/docs/面试指南/面试" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://832KKZBKZN-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Mr zhang Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Mr zhang Blog Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Mr zhang Blog" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.fa6a1188.css">
<link rel="preload" href="/assets/js/runtime~main.32344461.js" as="script">
<link rel="preload" href="/assets/js/main.36daeabe.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/hang.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/hang.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">我的网站</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/ZhRose/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/java---framework">JAVA - Framework</a><button aria-label="打开/收起侧边栏菜单「JAVA - Framework」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/javascript">JavaScript</a><button aria-label="打开/收起侧边栏菜单「JavaScript」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/java面试常见问题">Java面试常见问题</a><button aria-label="打开/收起侧边栏菜单「Java面试常见问题」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/面试指南/面试">集合中的泛型问题</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/java面试常见问题"><span itemprop="name">Java面试常见问题</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">集合中的泛型问题</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>集合中的泛型问题</h1><p>在Java中，<code>List&lt;? extends Animal&gt;</code> 表示一个元素为Animal或Animal的子类的列表。而 <code>new ArrayList&lt;dog&gt;()</code> 表示创建了一个ArrayList对象，并将其当做<code>List&lt;dog&gt;</code>类型的对象使用。</p><p>通过将dog传递给参数化类型，实际上是将 <code>ArrayList&lt;dog&gt;</code> 转换成了 <code>List&lt;? extends Animal&gt;</code> 类型，可以将其赋值并存储到类型为 <code>List&lt;? extends Animal&gt;</code> 的引用变量 list 中。</p><p>这样的好处是我们可以写出更通用、更灵活的代码，因为这样无论是哪种Animal的子类（如Cat、Tiger等）类型，都可以被存储到<code>List&lt;? extends Animal&gt;</code> 变量list中。</p><p>但需要注意的是，<code>List&lt;? extends Animal&gt;</code> 是一个泛型类型 ，强制转换子类可能会导致编译错误或运行时异常。另外，由于不确定具体的子类类型，所以一些操作(比如修改)对此类型的列表是不允许进行的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="linkedblockingqueue">LinkedBlockingQueue<a href="#linkedblockingqueue" class="hash-link" aria-label="LinkedBlockingQueue的直接链接" title="LinkedBlockingQueue的直接链接">​</a></h2><p>是一个无界阻塞队列，如果使用该线程执行任务，如果任务过多就会不断地添加到队列中，任务越多占用的内存就越大，最终可能会耗尽内存，导致OOM（Out of memory）<em>不建议用Executors.newFixedThreadPool()和其他工厂方法创建线程池，原因是底层采用的都是LinkedBlockingQueue队列</em>, 建议通过ThreadPoolExecutor来自定义线程池</p><p><img loading="lazy" src="C:%5CUsers%5Clonesome%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230612113413583.png" alt="image-20230612113413583" class="img_ev3q"></p><h1>线程</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1开启线程的方式">1.开启线程的方式<a href="#1开启线程的方式" class="hash-link" aria-label="1.开启线程的方式的直接链接" title="1.开启线程的方式的直接链接">​</a></h2><p>继承Thread类，继承Runnable接口，继承Callable接口，底层都是实现了Runnable接口</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2线程池有哪几种状态每种状态分别代表什么">2.线程池有哪几种状态，每种状态分别代表什么<a href="#2线程池有哪几种状态每种状态分别代表什么" class="hash-link" aria-label="2.线程池有哪几种状态，每种状态分别代表什么的直接链接" title="2.线程池有哪几种状态，每种状态分别代表什么的直接链接">​</a></h3><p>Running：线程池正常运行，既能接收新任务，也会正常处理队列中的任务</p><p>Shutdown:shutdown()方法,线程池处在正在关闭的状态，不会接受新的任务，但是会把队列中的任务处理完</p><p>Stop：shutdownnow()方法，线程池不会接收新任务了，也不会处理队列中的任务，并且正在运行的线程也会中断</p><p>Tidying:线程池中没有线程在运行后，线程池的状态就会自动变成TIDYING,并且调用terminated()</p><p>Terminated:terminated方法执行完成之后，线程池的状态就会变成Terminated</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3java创建线程的方式">3.java创建线程的方式<a href="#3java创建线程的方式" class="hash-link" aria-label="3.java创建线程的方式的直接链接" title="3.java创建线程的方式的直接链接">​</a></h3><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>通过实现Callble，创建FutereTask对象，并将callble对象放入FutureTask里，最后创建Thread线程,将futereTask交给Thread</li><li>基于线程池创建</li></ol><p><img loading="lazy" src="C:%5CUsers%5Clonesome%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230526160719124.png" alt="image-20230526160719124" class="img_ev3q"></p><p>一级缓存(singletonObjects)：保证了经过完整生命周期函数的代理对象</p><p>二级缓存(earlySingletonObjects)：出现循环依赖后，临时存放代理对象，保证单例</p><p>三级缓存(singletonFactories)：打破循环，当出现循环依赖后保证进行Aop，以及产生service代理对象</p><p><img loading="lazy" src="C:%5CUsers%5Clonesome%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230526161953464.png" alt="image-20230526161953464" class="img_ev3q"></p><h1>jvm</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1jvm中有几块区域作用分别是什么">1.jvm中有几块区域，作用分别是什么<a href="#1jvm中有几块区域作用分别是什么" class="hash-link" aria-label="1.jvm中有几块区域，作用分别是什么的直接链接" title="1.jvm中有几块区域，作用分别是什么的直接链接">​</a></h2><p>JVM的内存结构包括五大区域：<code>程序计数器</code>、<code>虚拟机栈</code>、<code>本地方法栈</code>、<code>堆区</code>、<code>方法区</code>。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p><p><strong>1，程序计数器（Program Counter Register）</strong>：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。</p><p>　　每个程序计数器只用来记录一个线程的行号，所以它是<strong>线程私有</strong>（一个线程就有一个程序计数器）的。</p><p>　　如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写 完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区 域中唯一一个没有定义OutOfMemoryError的区域。</p><p><strong>2，虚拟机栈（JVM Stack）</strong>：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p><p>　　局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占 用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定 好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p><p>　　虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多 数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，知道内存不足，此时，会抛出 OutOfMemoryError（内存溢出）。</p><p>　　每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p><p><strong>3，本地方法栈（Native Method Statck）</strong>：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p><p><strong>4，堆区（Heap）</strong>：堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区<strong>由所有线程共享</strong>，在虚拟机启动时创建。堆区的存在是为了<strong>存储对象实例</strong>，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p><p>　　一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主 流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p><p><strong>5，方法区（Method Area）</strong>：在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实 上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永 久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。</p><p>　　方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</p><p>　　方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上 执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对 常量池的内存回收和对已加载类的卸载。</p><p>　　在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。</p><p>　　在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。</p><p>　　运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p><p><strong>6，直接内存（Direct Memory）</strong>：直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是 JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区 （Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。 由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2java内存分配机制">2.java内存分配机制<a href="#2java内存分配机制" class="hash-link" aria-label="2.java内存分配机制的直接链接" title="2.java内存分配机制的直接链接">​</a></h2><ol><li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li><li>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li><li>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</li><li>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</li><li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li></ol><p>　　从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方 式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的<strong>“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）</strong>，这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。</p><p>　　在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread- Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对 象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干 段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内 存。</p><p>　　<strong>年老代（Old Generation）</strong>：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　</p><p> 　可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。</p><p>　　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</p><p>　　可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3java-gc机制">3.<strong>Java GC机制</strong><a href="#3java-gc机制" class="hash-link" aria-label="3java-gc机制的直接链接" title="3java-gc机制的直接链接">​</a></h2><p>GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。</p><p>　　<strong>年轻代：</strong></p><p>　　事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p><p>　　这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）</p><p>　　由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.</p><p>　　<strong>老年代：</strong></p><p>　　老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p><p>   在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设 置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不 允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p><p>　　<strong>方法区（永久代）：</strong></p><p>　　永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p><ol><li><p>类的所有实例都已经被回收</p></li><li><p>加载类的ClassLoader已经被回收</p></li><li><p>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</p><p>永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制</p><p>使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息</p><p>-verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用；</p><p>-XX:+TraceClassUnLoading需要fastdebug版HotSpot支持</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4垃圾收集器">4.垃圾收集器<a href="#4垃圾收集器" class="hash-link" aria-label="4.垃圾收集器的直接链接" title="4.垃圾收集器的直接链接">​</a></h2><p>​     在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同</p><ul><li><p>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</p></li><li><p>ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</p></li><li><p>Parallel Scavenge 收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用 Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即 1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）</p></li><li><p>Serial Old收集器：老年代收集器，单线程收集器，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存 的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标 记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</p></li><li><p>Parallel Old收集器：老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清 理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。</p></li><li><p>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5gc回收原理">5.gc回收原理<a href="#5gc回收原理" class="hash-link" aria-label="5.gc回收原理的直接链接" title="5.gc回收原理的直接链接">​</a></h2><p>GC (Garbage Collection:即垃圾回收)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">● 对新生代的对象的收集称为minor GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 对老年代的对象的收集称为Full GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 程序中主动调用System.gc()强制执行的GC为Full GC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 弱引用：在GC时一定会被GC回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">● 虚引用：由于虚引用只是用来得知对象是否被GC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-引用计数器早期策略">1. 引用计数器(早期策略)<a href="#1-引用计数器早期策略" class="hash-link" aria-label="1. 引用计数器(早期策略)的直接链接" title="1. 引用计数器(早期策略)的直接链接">​</a></h3><p>在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><p><strong>优点：</strong> 引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
<strong>缺点：</strong> 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-可达性分析主流策略">2. 可达性分析(主流策略)<a href="#2-可达性分析主流策略" class="hash-link" aria-label="2. 可达性分析(主流策略)的直接链接" title="2. 可达性分析(主流策略)的直接链接">​</a></h3><p>程序把所有的引用关系看作一张图，从一个节点GC Roots开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：
● 虚拟机栈中引用的对象（栈帧中的本地变量表）；
● 方法区中类静态属性引用的对象；
● 方法区中常量引用的对象；
● 本地方法栈中JNI（Native方法）引用的对象。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3标记-清除算法">3.标记-清除算法<a href="#3标记-清除算法" class="hash-link" aria-label="3.标记-清除算法的直接链接" title="3.标记-清除算法的直接链接">​</a></h3><p>标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
<strong>标记阶段：</strong>
标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的 GC Roots 对象，对从 GCRoots 对象可达的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象。
<strong>清除阶段：</strong>
清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header 信息），则将其回收。</p><p>在垃圾收集器进行 GC 时，必须停止所有 Java 执行线程（也称&quot;Stop The World&quot;），原因是在标记阶段进行可达性分析时，不可以出现分析过程中对象引用关系还在不断变化的情况，否则的话可达性分析结果的准确性就无法得到保证。在等待标记清除结束后，应用线程才会恢复运行。</p><p><strong>标记/清除算法缺点：</strong>
● <strong>效率问题</strong>
标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且 GC 时需要停止应用程序，这会导致非常差的用户体验。
● <strong>空间问题</strong>
标记清除之后会产生大量不连续的内存碎片（从上图可以看出），内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-复制算法">4. 复制算法<a href="#4-复制算法" class="hash-link" aria-label="4. 复制算法的直接链接" title="4. 复制算法的直接链接">​</a></h3><p>复制算法是将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉,复制算法每次都是对整个半区进行内存回收，这样就减少了标记对象遍历的时间，在清除使用区域对象时，不用进行遍历，直接清空整个区域内存，而且在将存活对象复制到保留区域时也是按地址顺序存储的，这样就解决了内存碎片的问题，在分配对象内存时不用考虑内存碎片等复杂问题，只需要按顺序分配内存即可。</p><p><strong>复制算法缺点：</strong>
复制算法简单高效，优化了标记清除算法的效率低、内存碎片多问题，存在缺点：
● 将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；
● 如果对象的存活率很高，极端一点的情况假设对象存活率为 100%，那么我们需要将所有存活的对象复制一遍，耗费的时间代价也是不可忽视的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-标记-整理算法">5. 标记-整理算法<a href="#5-标记-整理算法" class="hash-link" aria-label="5. 标记-整理算法的直接链接" title="5. 标记-整理算法的直接链接">​</a></h3><p>标记-整理算法算法与标记/清除算法很像，事实上，标记/整理算法的标记过程任然与标记/清除算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。可以看到，回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。这样一来，当我们给新对象分配内存时，jvm 只需要持有内存的起始地址即可。标记/整理算法弥补了标记/清除算法存在内存碎片的问题消除了复制算法内存减半的高额代价，可谓一举两得。</p><p><strong>标记/整理缺点：</strong>
● 效率不高：不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-分代回收算法">6. 分代回收算法<a href="#6-分代回收算法" class="hash-link" aria-label="6. 分代回收算法的直接链接" title="6. 分代回收算法的直接链接">​</a></h3><p>分代收集算法的思想是按对象的存活周期不同将内存划分为几块一般是把 Java 堆分为新生代和老年代（还有一个永久代，是 HotSpot 特有的实现，其他的虚拟机实现没有这一概念，永久代的收集效果很差，一般很少对永久代进行垃圾回收），这样就可以根据各个年代的特点采用最合适的收集算法。</p><p><strong>特点：</strong>
新生代：朝生夕灭，存活时间很短。采用复制算法来收集
老年代：经过多次 Minor GC 而存活下来，存活周期长。采用标记/清除算法或者标记/整理算法收集老年代</p><p>新生代中每次垃圾回收都发现有大量的对象死去，只有少量存活，因此采用复制算法回收新生代，只需要付出少量对象的复制成本就可以完成收集；
老年代中对象的存活率高，不适合采用复制算法，而且如果老年代采用复制算法，它是没有额外的空间进行分配担保的，因此必须使用标记/清理算法或者标记/整理算法来进行回收。</p><p>1、 大对象
大对象就是指需要大量连续内存空间的对象，最典型的就是那种很长的字符串和数组。大对象会直接进入到老年代，这样做的目的主要是为了避免新生代发生大量的内存复制（大对象的复制成本较高）。</p><p>2、长期存活的对象
虚拟机给每个对象都定义了一个对象年龄计数器。每当进行一次Minor GC，年龄就增加1岁，当年龄超过一定值时（默认是15，可以通过参数配置），就进入到老年代。</p><p>动态对象年龄判断
虚拟机并不要求对象年龄一定要到达15岁才进入到老年代。如果Survivor空间中有某年龄相同的所有对象大小总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就会直接进入老年代。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-finalize赋予对象重生">7. finalize()赋予对象重生<a href="#7-finalize赋予对象重生" class="hash-link" aria-label="7. finalize()赋予对象重生的直接链接" title="7. finalize()赋予对象重生的直接链接">​</a></h3><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p><p>在可达性分析算法中被标记为不可达的对象，也不一定是一定会被回收，它还有第二次重生的机会。每一个对象在被回收之前要进行两次标记，一次是没有关联引用链会被标记一次，第二次是判断该对象是否覆盖finalize()方法，如果没有覆盖则真正的被定了“死刑”。</p><p><img loading="lazy" src="D:%5CDesktop%5Cf8be841a2366452d9c63ddf4f67efd03.png" alt="img" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类的加载过程">类的加载过程<a href="#类的加载过程" class="hash-link" aria-label="类的加载过程的直接链接" title="类的加载过程的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1.加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过类的全限定名获取该类的二进制字节流、将二进制字节流所代表的静态结构转化为方法区的运行时数据结构、在内存中创建一个代表该类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.验证</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">验证阶段确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。（包括文件格式验证，元数据验证，字节码验证，符号引用验证）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3.准备</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。初始值通常情况下是数据类型的零值（0, null），如果该值被final修饰，那么他将在这个阶段直接被赋值为那个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4.解析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5.初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">类初始化阶段是类加载过程的最后一步，是执行类构造器 &lt;clinit&gt;() 方法的过程。&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="并发concurrency和并行parallellism是">并发（concurrency）和并行（parallellism）是：<a href="#并发concurrency和并行parallellism是" class="hash-link" aria-label="并发（concurrency）和并行（parallellism）是：的直接链接" title="并发（concurrency）和并行（parallellism）是：的直接链接">​</a></h2><ul><li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>解释三：并行是在一台处理器上“同时”处理多个任务，并发是在多台处理器上同时处理多个任务。如 hadoop 分布式集群。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="高可用性系统设计指南">高可用性系统设计指南<a href="#高可用性系统设计指南" class="hash-link" aria-label="高可用性系统设计指南的直接链接" title="高可用性系统设计指南的直接链接">​</a></h3><p>评判标准：代表系统即使发生硬件故障或者系统升级的时候，服务仍是可用的</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="导致系统不可用的情况">导致系统不可用的情况：<a href="#导致系统不可用的情况" class="hash-link" aria-label="导致系统不可用的情况：的直接链接" title="导致系统不可用的情况：的直接链接">​</a></h3><ol><li>黑客攻击 </li><li>硬件故障，比如服务器坏掉</li><li>并发量/用户请求量激增导致整个服务当掉或者部分服务不可用</li><li>代码中的坏味道导致内存泄露或其他问题导致程序挂掉</li><li>网站架构某个重要的角色比如Nginx或者数据库突然不可用</li><li>自然灾害或者人为破坏</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提高系统可用性的方法">提高系统可用性的方法:<a href="#提高系统可用性的方法" class="hash-link" aria-label="提高系统可用性的方法:的直接链接" title="提高系统可用性的方法:的直接链接">​</a></h3><ol><li>使用集群，减少单点故障</li><li>限流，当达到指定的阈值对流量进行控制，避免被瞬时的流量高峰冲垮</li><li>超时和重试机制 ,超出某个事件得不到响应，就抛出异常</li><li>熔断机制，当依赖的服务恶化或者调用次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务</li><li>异步调用：通过异步处理消息队列来提高性能</li><li>使用缓存</li><li>更好的硬件，监控系统资源使用情况增加报警设置</li><li>注意备份，必要时回滚，灰度分布</li><li>定期检查/更换硬件</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常见的限流算法">常见的限流算法：<a href="#常见的限流算法" class="hash-link" aria-label="常见的限流算法：的直接链接" title="常见的限流算法：的直接链接">​</a></h3><p><em>固定窗口计数器算法</em>：固定每个接口一段时间内可以被访问的次数</p><p><em>滑动窗口计数器算法</em>：把时间做了一个划分</p><p><em>漏桶算法</em></p><p><em>令牌桶算法</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="单例模式">单例模式<a href="#单例模式" class="hash-link" aria-label="单例模式的直接链接" title="单例模式的直接链接">​</a></h2><p>单例模式保证系统只有一个对象，不可以再让别的地方产生新的对象，通常在该类中先定义对象，然后将构造方法设置为私有，最后添加一个返回实例的方法对外暴露，但是当多线程访问时可以添加synchornized对象阻止并发访问，但是锁的添加方法应该放在方法的里面，然后通过Dcl的方法来检查两遍防止并发现象的发生</p><h3></h3><h1>JavaWEB</h1><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1原始的mybatis配置过程">1.原始的mybatis配置过程<a href="#1原始的mybatis配置过程" class="hash-link" aria-label="1.原始的mybatis配置过程的直接链接" title="1.原始的mybatis配置过程的直接链接">​</a></h3><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-将类路径下的xml文件以输入流的方式读入到程序中">1. 将类路径下的xml文件以输入流的方式读入到程序中<a href="#1-将类路径下的xml文件以输入流的方式读入到程序中" class="hash-link" aria-label="1. 将类路径下的xml文件以输入流的方式读入到程序中的直接链接" title="1. 将类路径下的xml文件以输入流的方式读入到程序中的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2创建sqlsessionfactorybuilder对象">2.创建sqlSessionFactoryBuilder对象<a href="#2创建sqlsessionfactorybuilder对象" class="hash-link" aria-label="2.创建sqlSessionFactoryBuilder对象的直接链接" title="2.创建sqlSessionFactoryBuilder对象的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3创建sqlsessionfactory对象创建mybatis实例的核心">3.创建sqlSessionFactory对象，创建mybatis实例的核心<a href="#3创建sqlsessionfactory对象创建mybatis实例的核心" class="hash-link" aria-label="3.创建sqlSessionFactory对象，创建mybatis实例的核心的直接链接" title="3.创建sqlSessionFactory对象，创建mybatis实例的核心的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="4配置文件中mybatisxml配置数据源信息并管理映射元文件usermapperxml">4.配置文件中（mybatis.xml）配置数据源信息，并管理映射元文件（userMapper.xml）<a href="#4配置文件中mybatisxml配置数据源信息并管理映射元文件usermapperxml" class="hash-link" aria-label="4.配置文件中（mybatis.xml）配置数据源信息，并管理映射元文件（userMapper.xml）的直接链接" title="4.配置文件中（mybatis.xml）配置数据源信息，并管理映射元文件（userMapper.xml）的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="5配置usermapperxml文件确定selectid返回类型和select语句">5.配置(userMapper.xml)文件，确定selectId,返回类型和select语句<a href="#5配置usermapperxml文件确定selectid返回类型和select语句" class="hash-link" aria-label="5.配置(userMapper.xml)文件，确定selectId,返回类型和select语句的直接链接" title="5.配置(userMapper.xml)文件，确定selectId,返回类型和select语句的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="6编辑dao层数据接口通过usermapperxml文件中的namespace与对应的全类名称一致">6.编辑dao层数据接口，通过userMapper.xml文件中的nameSpace与对应的全类名称一致<a href="#6编辑dao层数据接口通过usermapperxml文件中的namespace与对应的全类名称一致" class="hash-link" aria-label="6.编辑dao层数据接口，通过userMapper.xml文件中的nameSpace与对应的全类名称一致的直接链接" title="6.编辑dao层数据接口，通过userMapper.xml文件中的nameSpace与对应的全类名称一致的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="7sqlsessionfactoryopensession创建会话对象">7.sqlSessionFactory.openSession();创建会话对象<a href="#7sqlsessionfactoryopensession创建会话对象" class="hash-link" aria-label="7.sqlSessionFactory.openSession();创建会话对象的直接链接" title="7.sqlSessionFactory.openSession();创建会话对象的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="8通过sqlsession对象获取接口类对象">8.通过sqlSession对象获取接口类对象<a href="#8通过sqlsession对象获取接口类对象" class="hash-link" aria-label="8.通过sqlSession对象获取接口类对象的直接链接" title="8.通过sqlSession对象获取接口类对象的直接链接">​</a></h5><h5 class="anchor anchorWithStickyNavbar_LWe7" id="9执行接口中的方法并提交">9.执行接口中的方法并提交<a href="#9执行接口中的方法并提交" class="hash-link" aria-label="9.执行接口中的方法并提交的直接链接" title="9.执行接口中的方法并提交的直接链接">​</a></h5><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mybatis-plus配置过程">mybatis-plus配置过程<a href="#mybatis-plus配置过程" class="hash-link" aria-label="mybatis-plus配置过程的直接链接" title="mybatis-plus配置过程的直接链接">​</a></h3><p>1.添加mybatis-plus依赖包</p><p>2.在application.yml文件中配置mapper.xml文件的位置</p><p>3.配置全局的主键生成策略</p><p>4.创建实体类和mapper接口并继承baseMapper</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="springboot的项目目录">springboot的项目目录<a href="#springboot的项目目录" class="hash-link" aria-label="springboot的项目目录的直接链接" title="springboot的项目目录的直接链接">​</a></h3><p>一般根据业务逻辑可建立如下几个包：model(存放实体类以及自定义返回类型类，可以再一次划分问entity包以及request包)，mapper（作用于持久化层，和数据库打交道，根据业务逻辑建立相应的类），controller(作用于web层，通过访问相应的api接口调相应的实现具体业务的方法)，service(具体的逻辑代码实现层，连接mapper以及controller的中间层，一般建立相应的service接口以及impl实现类)，Utils(这是一个工具包，作用于全局的工具类可以建立在这个包中，一般建立本地缓存guava,MD5加密，自定义返回类，JWTS工具类等)，Interceptor(顾名思义这是一个拦截器的实现类，可以在此处实现逻辑拦截)，Config(配置类，拦截器的配置可以在此处实现，也可以添加一些特定类的配置)，Exception（自定义异常类，可以在此处自定义异常）</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="jsp和servlet有什么区别">jsp和servlet有什么区别<a href="#jsp和servlet有什么区别" class="hash-link" aria-label="jsp和servlet有什么区别的直接链接" title="jsp和servlet有什么区别的直接链接">​</a></h4><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="session-和-cookie-有什么区别">session 和 cookie 有什么区别？<a href="#session-和-cookie-有什么区别" class="hash-link" aria-label="session 和 cookie 有什么区别？的直接链接" title="session 和 cookie 有什么区别？的直接链接">​</a></h4><p>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。
安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。
容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。
存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="如何防止sql注入问题">如何防止SQL注入问题<a href="#如何防止sql注入问题" class="hash-link" aria-label="如何防止SQL注入问题的直接链接" title="如何防止SQL注入问题的直接链接">​</a></h4><p>可以使用#来进行sql语句的一个占位, #会·被解析为一个preStatement参数的类型，然后Mybatis会创建一个Prestatement对象，并将name作为参数传递给它执行查询,可以有效地防止sql注入攻击</p><p>$号会直接替换为相应的字符串，所以如果存在sql注入，该符号可能直接导致错误，因此需要更加谨慎使用</p><p>使用正则表达式过滤掉字符串中的特殊字符</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是xss攻击">什么是xss攻击<a href="#什么是xss攻击" class="hash-link" aria-label="什么是xss攻击的直接链接" title="什么是xss攻击的直接链接">​</a></h4><p>跨站脚本攻击，是web程序中常见的漏洞，原理是攻击者往web页面里插入恶意的脚本代码(css,js)等来盗取用户cookie或者重定向之类的问题</p><p>防御手段对输入的数据进行过滤操作</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是csrf攻击">什么是csrf攻击<a href="#什么是csrf攻击" class="hash-link" aria-label="什么是csrf攻击的直接链接" title="什么是csrf攻击的直接链接">​</a></h4><p>cross-site Request Forgerry 跨站请求伪造，攻击者盗用你的身份，以你的名义发送恶意请求。</p><p>防御手段：验证请求来源地址，关键操作添加验证代码，在请求地址添加token并验证</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="常见的异常类有哪些">常见的异常类有哪些？<a href="#常见的异常类有哪些" class="hash-link" aria-label="常见的异常类有哪些？的直接链接" title="常见的异常类有哪些？的直接链接">​</a></h4><p>NullPointerException 空指针异常
ClassNotFoundException 指定类不存在
NumberFormatException 字符串转换为数字异常
IndexOutOfBoundsException 数组下标越界异常
ClassCastException 数据类型转换异常
FileNotFoundException 文件未找到异常
NoSuchMethodException 方法不存在异常
IOException IO 异常
SocketException Socket 异常</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="get-和-post-请求有哪些区别">get 和 post 请求有哪些区别<a href="#get-和-post-请求有哪些区别" class="hash-link" aria-label="get 和 post 请求有哪些区别的直接链接" title="get 和 post 请求有哪些区别的直接链接">​</a></h4><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现跨域"><strong>如何实现跨域？</strong><a href="#如何实现跨域" class="hash-link" aria-label="如何实现跨域的直接链接" title="如何实现跨域的直接链接">​</a></h3><ul><li>服务器端运行跨域 设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="说一下你熟悉的设计模式">说一下你熟悉的设计模式？<a href="#说一下你熟悉的设计模式" class="hash-link" aria-label="说一下你熟悉的设计模式？的直接链接" title="说一下你熟悉的设计模式？的直接链接">​</a></h4><p>单例模式：保证被创建一次，节省系统开销。
工厂模式（简单工厂、抽象工厂）：解耦代码。
观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。
外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。
模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。
状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="spring-支持几种-bean-的作用域"><strong>spring 支持几种 bean 的作用域？</strong><a href="#spring-支持几种-bean-的作用域" class="hash-link" aria-label="spring-支持几种-bean-的作用域的直接链接" title="spring-支持几种-bean-的作用域的直接链接">​</a></h4><p>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；
prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；
Web 环境下的作用域：
request：每次 http 请求都会创建一个 bean；
session：同一个 http session 共享一个 bean 实例；
global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="事务的隔离级别">事务的隔离级别<a href="#事务的隔离级别" class="hash-link" aria-label="事务的隔离级别的直接链接" title="事务的隔离级别的直接链接">​</a></h4><ul><li>读未提交（Read Uncommitted）：事务可以读取未提交的数据，即一个事务修改了数据但尚未提交，另一个事务也能读到这个未提交的修改结果。这种隔离级别会导致脏读（dirty read）、不可重复读（non-repeatable read）和幻读（phantom read）等问题。</li><li>读已提交（Read Committed）：事务只能读取已提交的数据，即一个事务修改并提交了数据后，另一个事务才能看到这些修改结果。这种隔离级别可以避免脏读问题，但可能会出现不可重复读和幻读问题。</li><li>可重复读（Repeatable Read）：事务可以读取已提交的数据，并且在该事务内多次读取同一数据时，都能得到相同的结果（即数据不受其他事务的影响）。这种隔离级别可以避免脏读和不可重复读问题，但仍可能会出现幻读问题。</li><li>串行化（Serializable）：事务是依次串行执行的，每一个事务必须等待前一个事务完成后才能开始执行。这种隔离级别可以避免脏读、不可重复读和幻读问题，但是效率较低，不适用与高并发系统。</li><li>「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li>「不可重复读」 ：是指在一个事务内，多次读同一数据。</li><li>「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是springcloud">什么是springCloud?<a href="#什么是springcloud" class="hash-link" aria-label="什么是springCloud?的直接链接" title="什么是springCloud?的直接链接">​</a></h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署</p><p>Eureka：服务注册于发现。
Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。
Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。
Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-orm-框架"><strong>什么是 ORM 框架？</strong><a href="#什么是-orm-框架" class="hash-link" aria-label="什么是-orm-框架的直接链接" title="什么是-orm-框架的直接链接">​</a></h3><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="mybatis-逻辑分页和物理分页的区别是什么">MyBatis 逻辑分页和物理分页的区别是什么？<a href="#mybatis-逻辑分页和物理分页的区别是什么" class="hash-link" aria-label="MyBatis 逻辑分页和物理分页的区别是什么？的直接链接" title="MyBatis 逻辑分页和物理分页的区别是什么？的直接链接">​</a></h4><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。
物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="一张自增表里面总共有-7-条数据删除了最后-2-条数据重启-mysql-数据库又插入了一条数据此时-id-是几">一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？<a href="#一张自增表里面总共有-7-条数据删除了最后-2-条数据重启-mysql-数据库又插入了一条数据此时-id-是几" class="hash-link" aria-label="一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？的直接链接" title="一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？的直接链接">​</a></h4><p>表类型如果是 MyISAM ，那 id 就是 8。
表类型如果是 InnoDB，那 id 就是 6。
InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-的内连接左连接右连接有什么区别"><strong>MySQL 的内连接、左连接、右连接有什么区别？</strong><a href="#mysql-的内连接左连接右连接有什么区别" class="hash-link" aria-label="mysql-的内连接左连接右连接有什么区别的直接链接" title="mysql-的内连接左连接右连接有什么区别的直接链接">​</a></h3><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-索引是怎么实现的">MySQL 索引是怎么实现的？<a href="#mysql-索引是怎么实现的" class="hash-link" aria-label="MySQL 索引是怎么实现的？的直接链接" title="MySQL 索引是怎么实现的？的直接链接">​</a></h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="说一下mysql常用的引擎">说一下mysql常用的引擎<a href="#说一下mysql常用的引擎" class="hash-link" aria-label="说一下mysql常用的引擎的直接链接" title="说一下mysql常用的引擎的直接链接">​</a></h4><p>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(<em>) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。
MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(</em>) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选</p><p><img loading="lazy" src="C:%5CUsers%5Clonesome%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230612113526472.png" alt="image-20230612113526472" class="img_ev3q"></p><p><img loading="lazy" src="C:%5CUsers%5Clonesome%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230612113554707.png" alt="image-20230612113554707" class="img_ev3q"></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/java面试常见问题"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Java面试常见问题</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#linkedblockingqueue" class="table-of-contents__link toc-highlight">LinkedBlockingQueue</a></li><li><a href="#1开启线程的方式" class="table-of-contents__link toc-highlight">1.开启线程的方式</a><ul><li><a href="#2线程池有哪几种状态每种状态分别代表什么" class="table-of-contents__link toc-highlight">2.线程池有哪几种状态，每种状态分别代表什么</a></li><li><a href="#3java创建线程的方式" class="table-of-contents__link toc-highlight">3.java创建线程的方式</a></li></ul></li><li><a href="#1jvm中有几块区域作用分别是什么" class="table-of-contents__link toc-highlight">1.jvm中有几块区域，作用分别是什么</a></li><li><a href="#2java内存分配机制" class="table-of-contents__link toc-highlight">2.java内存分配机制</a></li><li><a href="#3java-gc机制" class="table-of-contents__link toc-highlight">3.<strong>Java GC机制</strong></a></li><li><a href="#4垃圾收集器" class="table-of-contents__link toc-highlight">4.垃圾收集器</a></li><li><a href="#5gc回收原理" class="table-of-contents__link toc-highlight">5.gc回收原理</a><ul><li><a href="#1-引用计数器早期策略" class="table-of-contents__link toc-highlight">1. 引用计数器(早期策略)</a></li><li><a href="#2-可达性分析主流策略" class="table-of-contents__link toc-highlight">2. 可达性分析(主流策略)</a></li><li><a href="#3标记-清除算法" class="table-of-contents__link toc-highlight">3.标记-清除算法</a></li><li><a href="#4-复制算法" class="table-of-contents__link toc-highlight">4. 复制算法</a></li><li><a href="#5-标记-整理算法" class="table-of-contents__link toc-highlight">5. 标记-整理算法</a></li><li><a href="#6-分代回收算法" class="table-of-contents__link toc-highlight">6. 分代回收算法</a></li><li><a href="#7-finalize赋予对象重生" class="table-of-contents__link toc-highlight">7. finalize()赋予对象重生</a></li></ul></li><li><a href="#类的加载过程" class="table-of-contents__link toc-highlight">类的加载过程</a></li><li><a href="#并发concurrency和并行parallellism是" class="table-of-contents__link toc-highlight">并发（concurrency）和并行（parallellism）是：</a><ul><li><a href="#高可用性系统设计指南" class="table-of-contents__link toc-highlight">高可用性系统设计指南</a></li><li><a href="#导致系统不可用的情况" class="table-of-contents__link toc-highlight">导致系统不可用的情况：</a></li><li><a href="#提高系统可用性的方法" class="table-of-contents__link toc-highlight">提高系统可用性的方法:</a></li><li><a href="#常见的限流算法" class="table-of-contents__link toc-highlight">常见的限流算法：</a></li></ul></li><li><a href="#单例模式" class="table-of-contents__link toc-highlight">单例模式</a><ul><li><a href="#1原始的mybatis配置过程" class="table-of-contents__link toc-highlight">1.原始的mybatis配置过程</a></li><li><a href="#mybatis-plus配置过程" class="table-of-contents__link toc-highlight">mybatis-plus配置过程</a></li><li><a href="#springboot的项目目录" class="table-of-contents__link toc-highlight">springboot的项目目录</a></li><li><a href="#如何实现跨域" class="table-of-contents__link toc-highlight"><strong>如何实现跨域？</strong></a></li><li><a href="#什么是-orm-框架" class="table-of-contents__link toc-highlight"><strong>什么是 ORM 框架？</strong></a></li><li><a href="#mysql-的内连接左连接右连接有什么区别" class="table-of-contents__link toc-highlight"><strong>MySQL 的内连接、左连接、右连接有什么区别？</strong></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.oschina.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">OSCHINA<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/ZhRose" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 zhanghang.Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.32344461.js"></script>
<script src="/assets/js/main.36daeabe.js"></script>
</body>
</html>